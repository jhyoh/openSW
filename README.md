# openSW

## top

- top 명령어는 Linux 운영체제에서 시스템의 실시간 성능 상태를 모니터링하는 데 사용되는 강력한 도구입니다.
  top 명령어를 실행하면 현재 실행 중인 프로세스, CPU 및 메모리 사용량, 시스템 부하, 그리고 기타 중요한 시스템 정보를 실시간으로 볼 수 있습니다.

**top 명령어 출력 설명**

**1. 헤더 부분**

   - **시스템 시간, 업타임:** 시스템의 현재 시간과 시스템이 얼마나 오래 실행되고 있는지 표시합니다.
   - **사용자 세션 정보:** 현재 로그인된 사용자 수를 표시합니다.
   - **로드 평균:** 지난 1분, 5분, 15분 동안의 시스템 부하 평균을 표시합니다.

**2. 작업 및 CPU 상태**

   - **Tasks:** 총 작업 수와 현재 실행 중, 대기 중, 중단됨, 좀비 상태인 작업 수를 표시합니다.
   - **Swap:** 스왑 메모리의 총량, 사용 중인 스왑, 사용 가능한 스왑, 스왑 입출력 등을 표시합니다.

**3. 메모리 사용**

   - **Mem:** 총 메모리, 사용 중인 메모리, 사용 가능한 메모리, 버퍼드 메모리, 캐시된 메모리 등을 표시합니다.
   - **Swap:** 스왑 메모리의 총량, 사용 중인 스왑, 사용 가능한 스왑, 스왑 입출력 등을 표시합니다.

**4. 프로세스 목록:**

   - **PID:** 프로세스 ID
   - **USER:** 프로세스를 실행하는 사용자
   - **PR:** 프로세스의 우선순위
   - **NI:** 프로세스의 nice 값
   - **VIRT:** 프로세스가 사용 중인 가상 메모리의 양
   - **RES:** 프로세스가 사용 중인 물리적 메모리의 양
   - **SHR:** 프로세스가 사용 중인 공유 메모리의 양
   - **S:** 프로세스 상태 (R=실행중, S=대기 중, D=중단할 수 없는 대기 중, Z=좀비상태, T=중지됨) 
   - **%CPU:** 프로세스가 사용하는 CPU 사용률
   - **%MEM:** 프로세스가 사용하는 메모리 사용률
   - **TIME+:** 프로세스가 시작된 이후 경과된 총 CPU 시간
   - **COMMAND:** 실행 중인 명령어

**5. 'top' 명령어에서 사용할 수 있는 인터랙티브 명령** : 'top' 명령어는 실행 중에 다양한 키를 입력하여 동작을 변경할 수 있습니다. 몇 가지 중요한 명령어는 다음과 같습니다.

   - **k:** 특정 프로세스를 종료합니다. 종료할 프로세스의 PID를 입력하라는 메시지가 표시됩니다.
   - **r:** 특정 프로세스의 우선순위를 변경합니다. 우선순위를 변경할 프로세스의 PID와 새로운 nice 값을 입력합니다.
   - **s:** 화면 갱신 주기를 설정합니다. 기본 값은 3초입니다.
   - **M:** 메모리 사용량 기준으로 프로세스를 정렬합니다.
   - **P:** CPU 사용량 기준으로 프로세스를 정렬합니다.
   - **T:** 프로세스가 사용한 시간 기준으로 프로세스를 정렬합니다.
   - **q:** 'top' 명령어를 종료합니다.
     
**6.** 'top' 명령어는 실행 시 다양한 옵션을 사용할 수 있습니다. 몇 가지 유용한 옵션은 다음과 같습니다.

   - **-d <갱신주기(단위:초)>:** 화면 갱신 주기를 설정합니다.
   - **-p <프로세스ID>:** 특정 PID를 모니터링합니다.
   - **-n <갱신횟수>:** 갱신 주기 횟수를 설정합니다.
     
**7. 요약:** 'top' 명령어는 시스템 성능 모니터링에 매우 유용하며, 다양한 옵션과 인터랙티브 명령을 통해 사용자가 필요에 맞게 화면을 구성하고 조작할 수 있습니다.

---

## ps

- 'ps'명령어는 Linux와 Unix 시스템에서 현재 실행 중인 프로세스의 상태를 확인하는 데 사용되는 명령어입니다. 'ps' 명령어는 다양한 옵션을 통해 원하는 프로셋스 정보만을 선택하여 출력할 수 있습니다. 기본적으로는 현재 터미널 세션에서 실행 중인 프로세스 목록을 출력합니다.


**1. 'ps'명령어의 주요 옵션**
   - **'ps aux':** 모든 사용자에 대한 모든 프로세스를 표시합니다.
   - **'ps -ef':** 풀 포맷으로 모든 프로세스를 출력합니다.
     
**2. 'ps'명령어 출력 필드 설명**
   - **USER:** 프로세스를 소유한 사용자
   - **PID:** 프로세스 ID
   - **%CPU:** 프로세스가 사용하는 CPU 시간의 백분율
   - **%MEM:** 프로세스가 사용하는 메모리 백분율
   - **VSZ:** 프로세스가 사용 중인 가상 메모리의 크기(단위:KB)
   - **RSS:** 프로세스가 사용 중인 상주 메모리의 크기(단위:KB)
   - **TTY:** 프로세스가 연결된 터미널
   - **STAT:** 프로세스의 상태 코드(S: 대기, R: 실행 중, Z: 좀비, T:중지 등)
   - **START:** 프로세스가 시작된 시간 또는 날짜
   - **TIME:** 프로세스가 사용한 총 CPU 시간
   - **COMMAND:** 프로세스를 시자갛는 데 사용 된 명령어
     
**3. 예제와 옵션 설명**
   - **모든 프로세스 보기('-e' 또는 '-A'):** 시스템의 모든 프로세스를 출력합니다.
   - **특정 사용자 프로세스 보기('-u <USERNAME>'):** 지정한 사용자의 프로세스만 출력합니다.
   - **트리 구조로 프로세스 보기('--forest'):** 프로세스를 트리 구조로 출력하여 프로세스 간의 부모-자식 관계를 쉽게 확인할 수 있습니다.
   - **특정 프로세스 ID 보기('-p PID'):** 지정한 PID에 해당하는 프로세스만 출력합니다.
   - **지정한 형식으로 출력('-o'):** 특정 필드를 지정하여 원하는 형식으로 프로세스 정보를 출력합니다. 예를들어

```sh
ps -eo pid,tty,time,cmd
```

  를
  입력하면 '-eo' 옵션은 '-e'(모든 프로세스)와 '-o'(출력 형식 지정)를 결합한 것으로, 'pid', 'tty', 'time', 'cmd' 필드를 출력합니다.

**4. 프로세스 상태 코드:** 'ps' 명령어의 출력 중 'STAT' 필드는 프로세스 상태를 나타냅니다. 주요 상태 코드는 다음과 같습니다:
   - **R:** Running(실행 중)
   - **S:** Sleeping(대기 중)
   - **D:** Uninterruptible Sleep(중단할 수 없는 대기 중)
   - **T:** Stopped(중지됨)
   - **Z:** Zombie (좀비 프로세스)
   - **X:** Dead (종료된 프로세스)
     
**5. 필터링 및 정렬:** 'ps'명령어는 다양한 방법으로 프로세스를 필터링하고 정렬할 수 있습니다. 예를 들어, 메모리 사용량 기준으로 정렬할 수 있습니다.

```sh
ps aux --sort=-%mem
```

 - 메모리 사용량이 높은 순서대로 프로세스를 출력합니다.
   
**6. 요약:** 'ps'명령어는 시스템 관리자와 사용자에게 현재 실행 중인 프로세스에 대한 상세한 정보를 제공합니다. 다양한 옵션과 결합하여 사용하면 시스템 모니터링과 문제 해결에 매우 유용합니다. 'man ps' 명령어를 통해 더 많은 옵션과 사용 방법을 확인할 수 있습니다.

---

## jobs

- 'jobs' 명령어는 Linux와 Unix 계열 운영체제에서 현재 셸 세션에 속한 직업(job)들의 상태를 표시하는 명령어입니다. 백그라운드 작업과 일시 중지된 작업 등을 관리할 때 유용하게 사용됩니다. 기본적으로 'jobs' 명령어는 현재 셸에서 실행 중이거나 일시 중지된 모든 작업의 목록을 출력합니다.

**1. 출력 형식**
   - **작업 번호:** 작업을 참조하는 번호입니다. 각 작업은 고유한 번호를 가집니다.
   - **작업 상태:** 작업이 현재 어떤 상태에 있는지 나타냅니다 *(Running, Stopped, Done 등).
   - **명령어:** 작업을 실행하는 데 사용된 명령어입니다.
     
```sh
$ jobs
[1]+ Stopped            vim
[2]- Running            ./long_running_process &
```

**2. 주요 옵션**
   - **-l:** PID를 포함한 추가 정보를 출력합니다.
   - **-n:** 최근에 상태가 변한 작업만 출력합니다.
   - **-p:** 각 작업의 프로세스 ID만 출력합니다.
   - **command:** 특정 작업에 대해 명령을 실행합니다.

**3. 작업 제어 관련 명령어:** 'jobs' 명령어와 함께 사용하는 다른 작업 제어 명령어도 있습니다.
   - **'bg':** 일시 중지된 작업을 백그라운드에서 실행하도록 합니다.
   - **'fg':** 백그라운드 작업을 포그라운드에서 실행하도록 합니다.
   - **'kill':** 작업을 종료합니다.

**4. 예제 시나리오**
   
   - **작업을 백그라운드로 보내기**
     
```sh
$ sleep 1000 &
[1] 12345
```

   - **현재 작업 목록 확인**
     
```sh
$ jobs
[1]+ Running              sleep 1000 &
```

   - **작업을 일시 중지**
     
```sh
$ kill -STOP %1
```

   - **작업 목록 확인**
     
```sh
$ jobs
[1]+ Stopped              sleep 1000
```

   - **작업을 백그라운드에서 재개**
     
```sh
$ bg %1
```

   - **작업 목록 확인**
     
```sh
$ jobs
[1]+ Running              sleep 1000 &
```

   - **작업을 포그라운드에서 재개**
     
```sh
$ fg %1
```

   - **작업을 종료**
     
```sh
$ kill %1
```

**5. 요약:** 'jobs' 명령어는 셸 세션에서 실행 중인 작업의 상태를 모니터링하고 관리하는 데 유용한 도구입니다. 백그라운드 작업, 포그라운드 작업, 일시 중지된 작업을 효율적으로 관리할 수 있게 하고 'jobs'와 함께 'bg', 'fg', 'kill' 등의 명령어를 사용하면 더욱 효과적으로 작업을 제어 할 수 있습니다.

---

## kill

- 'kill' 명령어는 Linux 및 Unix 계열 운영체제에서 프로세스를 종료하거나 신호를 보내기 위해 사용되는 명령어입니다. 'kill'명령어는 특정 프로세스 ID(PID)를 지정하여 해당 프로세스에 시그널을 보낼 수 있니다. 기본적으로, 'kill' 명령어는 종료 시그널('SIGTERM')을 보내지만, 다양한 시그널을 명시적으로 지정할 수도 있습니다.

**1. 기본 사용법**

```sh
kill [옵션] <PID>
```

   - 기본 시그널 (SIGTERM) 보내기
     
```sh
kill 1234
```

   - PID가 1234인 프로세스에 기본 종료 시그널('SIGTERM')을 보냅니다.
     
**2. 주요 시그널:** 'kill' 명령어는 다양한 시그널을 보낼 수 있습니다. 주요 시그널 몇 가지는 다음과 같습니다.
     
   - **SIGTERM (15):** 프로세스를 정상적으로 종료합니다. 프로세스가 종료할 시간을 가질 수 있습니다.
   - **SIGKILL (9):** 프로세스를 강제로 종료합니다. 프로세스가 종료될 수 없는 상황에서도 종료할 수 있습니다.
   - **SIGHUP (1):** 프로세스를 다시 로드 또는 재시작합니다.
   - **SIGINT (2):** 키보드 인터럽트('ctrl+c') 시그널을 보냅니다.
     
**3. 시그널을 지정하여 프로세스 종료하기**

```sh
kill -s SIGKILL 1234
```

   - PID가 1234인 프로세스에 'SIGKILL' 시그널을 보냅니다.
     
```sh
kill -9 1234
```

   - 동일한 방식으로 'SIGKILL' 시그널을 보냅니다. ('-9'는 'SIGKILL'의 시그널 번호).
     
**4. 여러 프로세스 종료하기**
```sh
kill 1234 5678 91011
```

   - PID가 1234, 5678, 91011인 여러 프로세스를 동시에 종료합니다.
     
**5. 특정 사용자 소유의 모든 프로세스 종료하기**

```sh
kill -u username
```

   - 지정한 사용자가 소유한 모든 프로세스를 종료합니다.
     
**6. 시그널 목록 보기**

```sh
kill -l
```

   - 시스템에서 사용할 수 있는 모든 시그널의 목록을 표시합니다.
     
출력 예제:

```sh
1) SIGHUP    2) SIGINT    3) SIGQUIT    4) SIGILL
5) SIGTRAP   6) SIGABRT   7) SIGBUS     9) SIGFPE
9) SIGKILL   10) SIGUSR1  11) SIGSEGV   12) SIGUSR2
..
```

**7. 프로세스 상태 확인 및 종료 예제**

   - **현재 실행 중인 프로세스 확인 ('ps' 명령어 사용)**
     
```sh
ps aux | grep process_name
```

   - **PID를 사용하여 프로세스 종료**

```sh
kill -9 1234
```

**8. 예제 시나리오**

   - **프로세스 목록 확인**

```sh
$ ps aux | grep httpd
root      2534  0.0  0.1  75424  3276  ?
www-data  2535  0.0  0.1  75424  3276  ?
www-data  2536  0.0  0.1  75424  3276  ?
```

   - **특정 PID 종료**

```sh
$ kill 2535
```

   - **강제종료**

```sh
$ kill -9 2535
```

**9. 요약:** 'kill' 명령어는 시스템 관리자가 프로세스를 관리하는데 필수적인 도구입니다. 기본 종료 시그널 외에도 다양한 시그널을 통해 프로세스에 특정 동작을 강제할 수 있습니다. 'kill' 명령어를 신중하게 사용하면 시스템의 안정성을 유지하면서 불필요한 프로세스를 효과적으로 관리할 수 있습니다.
